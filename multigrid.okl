@kernel void initialFConditions(const int N,
                        const float delta_x,
                        float *f) {
  for (int i = 0; i <= N; ++i; @tile(16, @outer, @inner)) {
    f[i] = delta_x*delta_x * M_PI*M_PI * std::sin(M_PI * i * delta_x);
  }
}

@kernel void initialConditions(const int N,
                        const int offset,
                        const float u_i,
                        const float u_0,
                        const float u_N,
                        float *u,
                        float *r) {
  for (int i = 0; i <= N; ++i; @tile(16, @outer, @inner)) {
    if (i == 0){
      u[i+offset] = u_0;
      r[i+offset] = 0.0;
    }
    else if (i == N) {
      u[i+offset] = u_N;
      r[i+offset] = 0.0;
    }
    else {
      u[i+offset] = u_i;
      r[i+offset] = 1.0;
    }
  }
}

@kernel void relaxation(const int N,
                        const int offset,
                        const float weight,
                        const float *f,
                        float *u,
                        float *u_star) {
  for (int i = 1; i < N; ++i; @tile(16, @outer, @inner)) {
    u_star[offset + i] = 0.5*(u[offset + i + 1] + u[offset + i - 1] + f[i]);
  }
  for (int i = 1; i < N; ++i; @tile(16, @outer, @inner)) {
    u[offset + i] += weight * (u_star[offset + i] - u[offset + i]);
  }
}

@kernel void residuals(const int N,
                        const int offset,
                        const float weight,
                        const float *f,
                        float *u,
                        float *u_star,
                        float *r) {
  for (int i = 1; i < N; ++i; @tile(16, @outer, @inner)) {
    u_star[offset + i] = 0.5*(u[offset + i + 1] + u[offset + i - 1] + f[i]);
  }
  for (int i = 1; i < N; ++i; @tile(16, @outer, @inner)) {
    r[offset + i] = weight * (u_star[offset + i] - u[offset + i]);
    u[offset + i] += r[offset + i];
  }
}

@kernel void restriction(const int N_coarse,
                        const int offset_coarse,
                        const int offset_fine,
                        float *f,
                        float *u,
                        const float *r) {
  for (int i = 1; i < N_coarse; ++i; @tile(16, @outer, @inner)) {
    f[offset_coarse + i] = 0.25*(r[offset_fine + 2*i - 1] + r[offset_fine + 2*i + 1] + 2.0*r[offset_fine + 2*i]);
    u[offset_coarse + i] = 0.0; // Initial guess for the velocity correction
  }
}

@kernel void prolongation(const int N_coarse,
                        const int offset_coarse,
                        const int offset_fine,
                        float *u) {
  for (int i = 0; i < N_coarse; ++i; @tile(16, @outer, @inner)) {
    u[offset_fine + 2*i] += u[offset_coarse + i];
    u[offset_fine + 2*i + 1] += 0.5 * (u[offset_coarse + i] + u[offset_coarse + i + 1]);
  }
}

// From occa example #4, from David Medina
@kernel void reduction_max(const int N,
                       const int offset,
                       const float *r,
                       float *block_max) {
  
  // Partial reduction of vector using loop tiles of size block (power of 2)
  for (int group = 0; group < ((N + 256 - 1) / 256); ++group; @outer) { // 256 is block size
    @shared float s_vec[256];

    for (int item = 0; item < 256; ++item; @inner) {
      if ((group * 256 + item) < N) {
        s_vec[item] = std::abs(r[offset + group * 256 + item]);
      } else {
        s_vec[item] = 0;
      }
    }

    for (int alive = ((256 + 1) / 2); 0 < alive; alive /= 2) {
      for (int item = 0; item < 256; ++item; @inner) {
        if (item < alive) {
          s_vec[item] = std::max(s_vec[item], s_vec[item + alive]);
        }
      }
    }

    for (int item = 0; item < 256; ++item; @inner) {
      if (item == 0) {
        block_max[group] = s_vec[0];
      }
    }
  }
}

// From occa example #4, from David Medina
@kernel void reduction_norm(const int N,
                       const int offset,
                       const float *r,
                       float *block_sum) {
  
  // Partial reduction of vector using loop tiles of size block (power of 2)
  for (int group = 0; group < ((N + 256 - 1) / 256); ++group; @outer) { // 256 is block size
    @shared float s_vec[256];

    for (int item = 0; item < 256; ++item; @inner) {
      if ((group * 256 + item) < N) {
        s_vec[item] = r[offset + group * 256 + item];
      } else {
        s_vec[item] = 0;
      }
    }

    for (int alive = ((256 + 1) / 2); 0 < alive; alive /= 2) {
      for (int item = 0; item < 256; ++item; @inner) {
        if (item < alive) {
          s_vec[item] += s_vec[item + alive];
        }
      }
    }

    for (int item = 0; item < 256; ++item; @inner) {
      if (item == 0) {
        block_sum[group] = s_vec[0];
      }
    }
  }
}